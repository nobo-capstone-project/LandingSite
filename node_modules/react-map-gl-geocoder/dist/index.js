'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

require('@mapbox/mapbox-gl-geocoder/dist/mapbox-gl-geocoder.css');

var _react = require('react');

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _mapboxGlGeocoder = require('@mapbox/mapbox-gl-geocoder');

var _mapboxGlGeocoder2 = _interopRequireDefault(_mapboxGlGeocoder);

var _reactMapGl = require('react-map-gl');

var _viewportMercatorProject = require('viewport-mercator-project');

var _viewportMercatorProject2 = _interopRequireDefault(_viewportMercatorProject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var VALID_POSITIONS = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];

function fitBounds(bounds, viewport) {
  return new _viewportMercatorProject2.default(viewport).fitBounds(bounds);
}

function getAccessToken() {
  var accessToken = null;

  if (typeof window !== 'undefined' && window.location) {
    var match = window.location.search.match(/access_token=([^&\/]*)/);
    accessToken = match && match[1];
  }

  if (!accessToken && typeof process !== 'undefined') {
    // Note: This depends on bundler plugins (e.g. webpack) inmporting environment correctly
    accessToken = accessToken || process.env.MapboxAccessToken; // eslint-disable-line
  }

  return accessToken || null;
}

var Geocoder = function (_Component) {
  _inherits(Geocoder, _Component);

  function Geocoder() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Geocoder);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Geocoder.__proto__ || Object.getPrototypeOf(Geocoder)).call.apply(_ref, [this].concat(args))), _this), _this.handleClear = function () {
      _this.props.onClear();
    }, _this.handleLoading = function (event) {
      _this.props.onLoading(event);
    }, _this.handleResults = function (event) {
      _this.props.onResults(event);
    }, _this.handleResult = function (event) {
      var result = event.result;
      var _this$props = _this.props,
          mapRef = _this$props.mapRef,
          onViewportChange = _this$props.onViewportChange,
          onResult = _this$props.onResult;
      var id = result.id,
          bbox = result.bbox,
          center = result.center;

      var _center = _slicedToArray(center, 2),
          longitude = _center[0],
          latitude = _center[1];

      var bboxExceptions = {
        'country.3148': {
          name: 'France',
          bbox: [[-4.59235, 41.380007], [9.560016, 51.148506]]
        },
        'country.3145': {
          name: 'United States',
          bbox: [[-171.791111, 18.91619], [-66.96466, 71.357764]]
        },
        'country.330': {
          name: 'Russia',
          bbox: [[19.66064, 41.151416], [190.10042, 81.2504]]
        },
        'country.3179': {
          name: 'Canada',
          bbox: [[-140.99778, 41.675105], [-52.648099, 83.23324]]
        }
      };
      var width = mapRef.current.props.width;
      var height = mapRef.current.props.height;
      var zoom = _this.geocoder.options.zoom;

      if (!bboxExceptions[id] && bbox) {
        zoom = fitBounds([[bbox[0], bbox[1]], [bbox[2], bbox[3]]], { width: width, height: height }).zoom;
      } else if (bboxExceptions[id]) {
        zoom = fitBounds(bboxExceptions[id].bbox, { width: width, height: height }).zoom;
      }

      if (_this.geocoder.options.flyTo) {
        onViewportChange({
          longitude: longitude,
          latitude: latitude,
          zoom: zoom,
          transitionInterpolator: new _reactMapGl.FlyToInterpolator(),
          transitionDuration: 3000
        });
      } else {
        onViewportChange({ longitude: longitude, latitude: latitude, zoom: zoom });
      }

      onResult(event);
    }, _this.handleError = function (event) {
      _this.props.onError(event);
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Geocoder, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      // mapRef is undefined on initial page load, so force an update to initialize geocoder
      this.forceUpdate();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this.geocoder) {
        this.geocoder = null;
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      if (this.geocoder !== undefined) {
        return;
      }

      var _props = this.props,
          mapRef = _props.mapRef,
          mapboxApiAccessToken = _props.mapboxApiAccessToken,
          zoom = _props.zoom,
          flyTo = _props.flyTo,
          placeholder = _props.placeholder,
          proximity = _props.proximity,
          trackProximity = _props.trackProximity,
          bbox = _props.bbox,
          types = _props.types,
          country = _props.country,
          minLength = _props.minLength,
          limit = _props.limit,
          language = _props.language,
          filter = _props.filter,
          localGeocoder = _props.localGeocoder,
          options = _props.options,
          onInit = _props.onInit,
          position = _props.position;


      this.geocoder = new _mapboxGlGeocoder2.default(_extends({
        accessToken: mapboxApiAccessToken,
        zoom: zoom,
        flyTo: flyTo,
        placeholder: placeholder,
        proximity: proximity,
        trackProximity: trackProximity,
        bbox: bbox,
        types: types,
        country: country,
        minLength: minLength,
        limit: limit,
        language: language,
        filter: filter,
        localGeocoder: localGeocoder
      }, options));
      this.geocoder.on('clear', this.handleClear);
      this.geocoder.on('loading', this.handleLoading);
      this.geocoder.on('results', this.handleResults);
      this.geocoder.on('result', this.handleResult);
      this.geocoder.on('error', this.handleError);

      mapRef.current.getMap().addControl(this.geocoder, VALID_POSITIONS.find(function (_position) {
        return position === _position;
      }));

      onInit(this.geocoder);
    }
  }, {
    key: 'getGeocoder',
    value: function getGeocoder() {
      return this.geocoder;
    }
  }, {
    key: 'render',
    value: function render() {
      return null;
    }
  }]);

  return Geocoder;
}(_react.Component);

Geocoder.propTypes = {
  mapRef: _propTypes2.default.object.isRequired,
  onViewportChange: _propTypes2.default.func.isRequired,
  mapboxApiAccessToken: _propTypes2.default.string,
  zoom: _propTypes2.default.number,
  flyTo: _propTypes2.default.bool,
  placeholder: _propTypes2.default.string,
  proximity: _propTypes2.default.object,
  trackProximity: _propTypes2.default.bool,
  bbox: _propTypes2.default.array,
  types: _propTypes2.default.string,
  country: _propTypes2.default.string,
  minLength: _propTypes2.default.number,
  limit: _propTypes2.default.number,
  language: _propTypes2.default.string,
  filter: _propTypes2.default.func,
  localGeocoder: _propTypes2.default.func,
  position: _propTypes2.default.oneOf(VALID_POSITIONS),
  onInit: _propTypes2.default.func,
  onClear: _propTypes2.default.func,
  onLoading: _propTypes2.default.func,
  onResults: _propTypes2.default.func,
  onResult: _propTypes2.default.func,
  onError: _propTypes2.default.func,
  options: _propTypes2.default.object // deprecated and will be removed in v2
};
Geocoder.defaultProps = {
  mapboxApiAccessToken: getAccessToken(),
  zoom: 16,
  flyTo: true,
  placeholder: 'Search',
  trackProximity: false,
  minLength: 2,
  limit: 5,
  position: 'top-right',
  onInit: function onInit() {},
  onClear: function onClear() {},
  onLoading: function onLoading() {},
  onResults: function onResults() {},
  onResult: function onResult() {},
  onError: function onError() {}
};
exports.default = Geocoder;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJWQUxJRF9QT1NJVElPTlMiLCJmaXRCb3VuZHMiLCJib3VuZHMiLCJ2aWV3cG9ydCIsIldlYk1lcmNhdG9yVmlld3BvcnQiLCJnZXRBY2Nlc3NUb2tlbiIsImFjY2Vzc1Rva2VuIiwid2luZG93IiwibG9jYXRpb24iLCJtYXRjaCIsInNlYXJjaCIsInByb2Nlc3MiLCJlbnYiLCJNYXBib3hBY2Nlc3NUb2tlbiIsIkdlb2NvZGVyIiwiaGFuZGxlQ2xlYXIiLCJwcm9wcyIsIm9uQ2xlYXIiLCJoYW5kbGVMb2FkaW5nIiwiZXZlbnQiLCJvbkxvYWRpbmciLCJoYW5kbGVSZXN1bHRzIiwib25SZXN1bHRzIiwiaGFuZGxlUmVzdWx0IiwicmVzdWx0IiwibWFwUmVmIiwib25WaWV3cG9ydENoYW5nZSIsIm9uUmVzdWx0IiwiaWQiLCJiYm94IiwiY2VudGVyIiwibG9uZ2l0dWRlIiwibGF0aXR1ZGUiLCJiYm94RXhjZXB0aW9ucyIsIm5hbWUiLCJ3aWR0aCIsImN1cnJlbnQiLCJoZWlnaHQiLCJ6b29tIiwiZ2VvY29kZXIiLCJvcHRpb25zIiwiZmx5VG8iLCJ0cmFuc2l0aW9uSW50ZXJwb2xhdG9yIiwiRmx5VG9JbnRlcnBvbGF0b3IiLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJoYW5kbGVFcnJvciIsIm9uRXJyb3IiLCJmb3JjZVVwZGF0ZSIsInVuZGVmaW5lZCIsIm1hcGJveEFwaUFjY2Vzc1Rva2VuIiwicGxhY2Vob2xkZXIiLCJwcm94aW1pdHkiLCJ0cmFja1Byb3hpbWl0eSIsInR5cGVzIiwiY291bnRyeSIsIm1pbkxlbmd0aCIsImxpbWl0IiwibGFuZ3VhZ2UiLCJmaWx0ZXIiLCJsb2NhbEdlb2NvZGVyIiwib25Jbml0IiwicG9zaXRpb24iLCJNYXBib3hHZW9jb2RlciIsIm9uIiwiZ2V0TWFwIiwiYWRkQ29udHJvbCIsImZpbmQiLCJfcG9zaXRpb24iLCJDb21wb25lbnQiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJvYmplY3QiLCJpc1JlcXVpcmVkIiwiZnVuYyIsInN0cmluZyIsIm51bWJlciIsImJvb2wiLCJhcnJheSIsIm9uZU9mIiwiZGVmYXVsdFByb3BzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBLElBQU1BLGtCQUFrQixDQUFDLFVBQUQsRUFBYSxXQUFiLEVBQTBCLGFBQTFCLEVBQXlDLGNBQXpDLENBQXhCOztBQUVBLFNBQVNDLFNBQVQsQ0FBbUJDLE1BQW5CLEVBQTJCQyxRQUEzQixFQUFxQztBQUNuQyxTQUFPLElBQUlDLGlDQUFKLENBQXdCRCxRQUF4QixFQUFrQ0YsU0FBbEMsQ0FBNENDLE1BQTVDLENBQVA7QUFDRDs7QUFFRCxTQUFTRyxjQUFULEdBQTBCO0FBQ3hCLE1BQUlDLGNBQWMsSUFBbEI7O0FBRUEsTUFBSSxPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLElBQWlDQSxPQUFPQyxRQUE1QyxFQUFzRDtBQUNwRCxRQUFJQyxRQUFRRixPQUFPQyxRQUFQLENBQWdCRSxNQUFoQixDQUF1QkQsS0FBdkIsQ0FBNkIsd0JBQTdCLENBQVo7QUFDQUgsa0JBQWNHLFNBQVNBLE1BQU0sQ0FBTixDQUF2QjtBQUNEOztBQUVELE1BQUksQ0FBQ0gsV0FBRCxJQUFnQixPQUFPSyxPQUFQLEtBQW1CLFdBQXZDLEVBQW9EO0FBQ2xEO0FBQ0FMLGtCQUFjQSxlQUFlSyxRQUFRQyxHQUFSLENBQVlDLGlCQUF6QyxDQUZrRCxDQUVTO0FBQzVEOztBQUVELFNBQU9QLGVBQWUsSUFBdEI7QUFDRDs7SUFFS1EsUTs7Ozs7Ozs7Ozs7Ozs7MExBa0VKQyxXLEdBQWMsWUFBTTtBQUNsQixZQUFLQyxLQUFMLENBQVdDLE9BQVg7QUFDRCxLLFFBRURDLGEsR0FBZ0IsVUFBQ0MsS0FBRCxFQUFXO0FBQ3pCLFlBQUtILEtBQUwsQ0FBV0ksU0FBWCxDQUFxQkQsS0FBckI7QUFDRCxLLFFBRURFLGEsR0FBZ0IsVUFBQ0YsS0FB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ZW50IjpbImltcG9ydCAnQG1hcGJveC9tYXBib3gtZ2wtZ2VvY29kZXIvZGlzdC9tYXBib3gtZ2wtZ2VvY29kZXIuY3NzJ1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgTWFwYm94R2VvY29kZXIgZnJvbSAnQG1hcGJveC9tYXBib3gtZ2wtZ2VvY29kZXInXG5pbXBvcnQgeyBGbHlUb0ludGVycG9sYXRvciB9IGZyb20gJ3JlYWN0LW1hcC1nbCdcbmltcG9ydCBXZWJNZXJjYXRvclZpZXdwb3J0IGZyb20gJ3ZpZXdwb3J0LW1lcmNhdG9yLXByb2plY3QnXG5cbmNvbnN0IFZBTElEX1BPU0lUSU9OUyA9IFsndG9wLWxlZnQnLCAndG9wLXJpZ2h0JywgJ2JvdHRvbS1sZWZ0JywgJ2JvdHRvbS1yaWdodCddXG5cbmZ1bmN0aW9uIGZpdEJvdW5kcyhib3VuZHMsIHZpZXdwb3J0KSB7XG4gIHJldHVybiBuZXcgV2ViTWVyY2F0b3JWaWV3cG9ydCh2aWV3cG9ydCkuZml0Qm91bmRzKGJvdW5kcylcbn1cblxuZnVuY3Rpb24gZ2V0QWNjZXNzVG9rZW4oKSB7XG4gIHZhciBhY2Nlc3NUb2tlbiA9IG51bGxcblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2F0aW9uKSB7XG4gICAgdmFyIG1hdGNoID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC5tYXRjaCgvYWNjZXNzX3Rva2VuPShbXiZcXC9dKikvKVxuICAgIGFjY2Vzc1Rva2VuID0gbWF0Y2ggJiYgbWF0Y2hbMV1cbiAgfVxuXG4gIGlmICghYWNjZXNzVG9rZW4gJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gTm90ZTogVGhpcyBkZXBlbmRzIG9uIGJ1bmRsZXIgcGx1Z2lucyAoZS5nLiB3ZWJwYWNrKSBpbm1wb3J0aW5nIGVudmlyb25tZW50IGNvcnJlY3RseVxuICAgIGFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW4gfHwgcHJvY2Vzcy5lbnYuTWFwYm94QWNjZXNzVG9rZW4gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB9XG5cbiAgcmV0dXJuIGFjY2Vzc1Rva2VuIHx8IG51bGxcbn1cblxuY2xhc3MgR2VvY29kZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAvLyBtYXBSZWYgaXMgdW5kZWZpbmVkIG9uIGluaXRpYWwgcGFnZSBsb2FkLCBzbyBmb3JjZSBhbiB1cGRhdGUgdG8gaW5pdGlhbGl6ZSBnZW9jb2RlclxuICAgIHRoaXMuZm9yY2VVcGRhdGUoKVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuZ2VvY29kZXIpIHtcbiAgICAgIHRoaXMuZ2VvY29kZXIgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIGlmICh0aGlzLmdlb2NvZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIG1hcFJlZixcbiAgICAgIG1hcGJveEFwaUFjY2Vzc1Rva2VuLFxuICAgICAgem9vbSxcbiAgICAgIGZseVRvLFxuICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICBwcm94aW1pdHksXG4gICAgICB0cmFja1Byb3hpbWl0eSxcbiAgICAgIGJib3gsXG4gICAgICB0eXBlcyxcbiAgICAgIGNvdW50cnksXG4gICAgICBtaW5MZW5ndGgsXG4gICAgICBsaW1pdCxcbiAgICAgIGxhbmd1YWdlLFxuICAgICAgZmlsdGVyLFxuICAgICAgbG9jYWxHZW9jb2RlcixcbiAgICAgIG9wdGlvbnMsXG4gICAgICBvbkluaXQsXG4gICAgICBwb3NpdGlvblxuICAgIH0gPSB0aGlzLnByb3BzXG5cbiAgICB0aGlzLmdlb2NvZGVyID0gbmV3IE1hcGJveEdlb2NvZGVyKHtcbiAgICAgIGFjY2Vzc1Rva2VuOiBtYXBib3hBcGlBY2Nlc3NUb2tlbixcbiAgICAgIHpvb20sXG4gICAgICBmbHlUbyxcbiAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgcHJveGltaXR5LFxuICAgICAgdHJhY2tQcm94aW1pdHksXG4gICAgICBiYm94LFxuICAgICAgdHlwZXMsXG4gICAgICBjb3VudHJ5LFxuICAgICAgbWluTGVuZ3RoLFxuICAgICAgbGltaXQsXG4gICAgICBsYW5ndWFnZSxcbiAgICAgIGZpbHRlcixcbiAgICAgIGxvY2FsR2VvY29kZXIsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSlcbiAgICB0aGlzLmdlb2NvZGVyLm9uKCdjbGVhcicsIHRoaXMuaGFuZGxlQ2xlYXIpXG4gICAgdGhpcy5nZW9jb2Rlci5vbignbG9hZGluZycsIHRoaXMuaGFuZGxlTG9hZGluZylcbiAgICB0aGlzLmdlb2NvZGVyLm9uKCdyZXN1bHRzJywgdGhpcy5oYW5kbGVSZXN1bHRzKVxuICAgIHRoaXMuZ2VvY29kZXIub24oJ3Jlc3VsdCcsIHRoaXMuaGFuZGxlUmVzdWx0KVxuICAgIHRoaXMuZ2VvY29kZXIub24oJ2Vycm9yJywgdGhpcy5oYW5kbGVFcnJvcilcblxuICAgIG1hcFJlZi5jdXJyZW50LmdldE1hcCgpLmFkZENvbnRyb2wodGhpcy5nZW9jb2RlciwgVkFMSURfUE9TSVRJT05TLmZpbmQoKF9wb3NpdGlvbikgPT4gcG9zaXRpb24gPT09IF9wb3NpdGlvbikpXG5cbiAgICBvbkluaXQodGhpcy5nZW9jb2RlcilcbiAgfVxuXG4gIGhhbmRsZUNsZWFyID0gKCkgPT4ge1xuICAgIHRoaXMucHJvcHMub25DbGVhcigpXG4gIH1cblxuICBoYW5kbGVMb2FkaW5nID0gKGV2ZW50KSA9PiB7XG4gICAgdGhpcy5wcm9wcy5vbkxvYWRpbmcoZXZlbnQpXG4gIH1cblxuICBoYW5kbGVSZXN1bHRzID0gKGV2ZW50KSA9PiB7XG4gICAgdGhpcy5wcm9wcy5vblJlc3VsdHMoZXZlbnQpXG4gIH1cblxuICBoYW5kbGVSZXN1bHQgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gZXZlbnRcbiAgICBjb25zdCB7IG1hcFJlZiwgb25WaWV3cG9ydENoYW5nZSwgb25SZXN1bHQgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCB7IGlkLCBiYm94LCBjZW50ZXIgfSA9IHJlc3VsdFxuICAgIGNvbnN0IFtsb25naXR1ZGUsIGxhdGl0dWRlXSA9IGNlbnRlclxuICAgIGNvbnN0IGJib3hFeGNlcHRpb25zID0ge1xuICAgICAgJ2NvdW50cnkuMzE0OCc6IHtcbiAgICAgICAgbmFtZTogJ0ZyYW5jZScsXG4gICAgICAgIGJib3g6IFtbLTQuNTkyMzUsIDQxLjM4MDAwN10sIFs5LjU2MDAxNiwgNTEuMTQ4NTA2XV1cbiAgICAgIH0sXG4gICAgICAnY291bnRyeS4zMTQ1Jzoge1xuICAgICAgICBuYW1lOiAnVW5pdGVkIFN0YXRlcycsXG4gICAgICAgIGJib3g6IFtbLTE3MS43OTExMTEsIDE4LjkxNjE5XSwgWy02Ni45NjQ2NiwgNzEuMzU3NzY0XV1cbiAgICAgIH0sXG4gICAgICAnY291bnRyeS4zMzAnOiB7XG4gICAgICAgIG5hbWU6ICdSdXNzaWEnLFxuICAgICAgICBiYm94OiBbWzE5LjY2MDY0LCA0MS4xNTE0MTZdLCBbMTkwLjEwMDQyLCA4MS4yNTA0XV1cbiAgICAgIH0sXG4gICAgICAnY291bnRyeS4zMTc5Jzoge1xuICAgICAgICBuYW1lOiAnQ2FuYWRhJyxcbiAgICAgICAgYmJveDogW1stMTQwLjk5Nzc4LCA0MS42NzUxMDVdLCBbLTUyLjY0ODA5OSwgODMuMjMzMjRdXVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB3aWR0aCA9IG1hcFJlZi5jdXJyZW50LnByb3BzLndpZHRoXG4gICAgY29uc3QgaGVpZ2h0ID0gbWFwUmVmLmN1cnJlbnQucHJvcHMuaGVpZ2h0XG4gICAgbGV0IHpvb20gPSB0aGlzLmdlb2NvZGVyLm9wdGlvbnMuem9vbVxuXG4gICAgaWYgKCFiYm94RXhjZXB0aW9uc1tpZF0gJiYgYmJveCkge1xuICAgICAgem9vbSA9IGZpdEJvdW5kcyhbW2Jib3hbMF0sIGJib3hbMV1dLCBbYmJveFsyXSwgYmJveFszXV1dLCB7IHdpZHRoLCBoZWlnaHQgfSkuem9vbVxuICAgIH0gZWxzZSBpZiAoYmJveEV4Y2VwdGlvbnNbaWRdKSB7XG4gICAgICB6b29tID0gZml0Qm91bmRzKGJib3hFeGNlcHRpb25zW2lkXS5iYm94LCB7IHdpZHRoLCBoZWlnaHQgfSkuem9vbVxuICAgIH1cblxuICAgIGlmICh0aGlzLmdlb2NvZGVyLm9wdGlvbnMuZmx5VG8pIHtcbiAgICAgIG9uVmlld3BvcnRDaGFuZ2Uoe1xuICAgICAgICBsb25naXR1ZGUsXG4gICAgICAgIGxhdGl0dWRlLFxuICAgICAgICB6b29tLFxuICAgICAgICB0cmFuc2l0aW9uSW50ZXJwb2xhdG9yOiBuZXcgRmx5VG9JbnRlcnBvbGF0b3IoKSxcbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiAzMDAwXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBvblZpZXdwb3J0Q2hhbmdlKHsgbG9uZ2l0dWRlLCBsYXRpdHVkZSwgem9vbSB9KVxuICAgIH1cblxuICAgIG9uUmVzdWx0KGV2ZW50KVxuICB9XG5cbiAgaGFuZGxlRXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICB0aGlzLnByb3BzLm9uRXJyb3IoZXZlbnQpXG4gIH1cblxuICBnZXRHZW9jb2RlcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9jb2RlclxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIG1hcFJlZjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgIG9uVmlld3BvcnRDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgbWFwYm94QXBpQWNjZXNzVG9rZW46IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgem9vbTogUHJvcFR5cGVzLm51bWJlcixcbiAgICBmbHlUbzogUHJvcFR5cGVzLmJvb2wsXG4gICAgcGxhY2Vob2xkZXI6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgcHJveGltaXR5OiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIHRyYWNrUHJveGltaXR5OiBQcm9wVHlwZXMuYm9vbCxcbiAgICBiYm94OiBQcm9wVHlwZXMuYXJyYXksXG4gICAgdHlwZXM6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgY291bnRyeTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBtaW5MZW5ndGg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgbGltaXQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgbGFuZ3VhZ2U6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgZmlsdGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBsb2NhbEdlb2NvZGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBwb3NpdGlvbjogUHJvcFR5cGVzLm9uZU9mKFZBTElEX1BPU0lUSU9OUyksXG4gICAgb25Jbml0OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNsZWFyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkxvYWRpbmc6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uUmVzdWx0czogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25SZXN1bHQ6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uRXJyb3I6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9wdGlvbnM6IFByb3BUeXBlcy5vYmplY3QgLy8gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHYyXG4gIH1cblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIG1hcGJveEFwaUFjY2Vzc1Rva2VuOiBnZXRBY2Nlc3NUb2tlbigpLFxuICAgIHpvb206IDE2LFxuICAgIGZseVRvOiB0cnVlLFxuICAgIHBsYWNlaG9sZGVyOiAnU2VhcmNoJyxcbiAgICB0cmFja1Byb3hpbWl0eTogZmFsc2UsXG4gICAgbWluTGVuZ3RoOiAyLFxuICAgIGxpbWl0OiA1LFxuICAgIHBvc2l0aW9uOiAndG9wLXJpZ2h0JyxcbiAgICBvbkluaXQ6ICgpID0+IHt9LFxuICAgIG9uQ2xlYXI6ICgpID0+IHt9LFxuICAgIG9uTG9hZGluZzogKCkgPT4ge30sXG4gICAgb25SZXN1bHRzOiAoKSA9PiB7fSxcbiAgICBvblJlc3VsdDogKCkgPT4ge30sXG4gICAgb25FcnJvcjogKCkgPT4ge31cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBHZW9jb2RlclxuIl19